From 39a2141abd8fd7c2723c4276a3501cb9cb120550 Mon Sep 17 00:00:00 2001
From: Kathleen Brade <brade@pearlcrescent.com>
Date: Wed, 28 Nov 2012 15:08:40 -0500
Subject: [PATCH 23/26] Do not expose system colors to CSS or canvas.

---
 content/canvas/src/nsCanvasRenderingContext2D.cpp  |   28 +++-
 .../canvas/src/nsCanvasRenderingContext2DAzure.cpp |   34 +++-
 .../canvas/src/nsCanvasRenderingContext2DAzure.h   |    5 +-
 layout/style/nsRuleNode.cpp                        |    5 +-
 widget/LookAndFeel.h                               |    9 +
 widget/xpwidgets/nsXPLookAndFeel.cpp               |  173 +++++++++++++++++++-
 widget/xpwidgets/nsXPLookAndFeel.h                 |    5 +-
 7 files changed, 239 insertions(+), 20 deletions(-)

diff --git a/content/canvas/src/nsCanvasRenderingContext2D.cpp b/content/canvas/src/nsCanvasRenderingContext2D.cpp
index 0dec654..7132e4f 100644
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp
@@ -32,6 +32,7 @@
 #include "nsCSSParser.h"
 #include "mozilla/css/StyleRule.h"
 #include "mozilla/css/Declaration.h"
+#include "mozilla/css/Loader.h"
 #include "nsComputedDOMStyle.h"
 #include "nsStyleSet.h"
 
@@ -159,8 +160,9 @@ class nsCanvasGradient MOZ_FINAL : public nsIDOMCanvasGradient
 public:
     NS_DECLARE_STATIC_IID_ACCESSOR(NS_CANVASGRADIENT_PRIVATE_IID)
 
-    nsCanvasGradient(gfxPattern* pat)
-        : mPattern(pat)
+    nsCanvasGradient(mozilla::css::Loader* aLoader, gfxPattern* pat)
+        : mCSSLoader(aLoader)
+        , mPattern(pat)
     {
     }
 
@@ -181,8 +183,17 @@ public:
             return NS_ERROR_DOM_SYNTAX_ERR;
         }
 
+        nsIPresShell* presShell = nullptr;
+        if (mCSSLoader) {
+          nsIDocument *doc = mCSSLoader->GetDocument();
+          if (doc)
+            presShell = doc->GetShell();
+        }
+
         nscolor color;
-        if (!nsRuleNode::ComputeColor(value, nullptr, nullptr, color)) {
+        if (!nsRuleNode::ComputeColor(value,
+                           presShell ? presShell->GetPresContext() : nullptr,
+                           nullptr, color)) {
             return NS_ERROR_DOM_SYNTAX_ERR;
         }
 
@@ -194,6 +205,7 @@ public:
     NS_DECL_ISUPPORTS
 
 protected:
+    mozilla::css::Loader* mCSSLoader; // not ref counted, it owns us
     nsRefPtr<gfxPattern> mPattern;
 };
 
@@ -1814,7 +1826,10 @@ nsCanvasRenderingContext2D::CreateLinearGradient(float x0, float y0, float x1, f
     if (!gradpat)
         return NS_ERROR_OUT_OF_MEMORY;
 
-    nsRefPtr<nsIDOMCanvasGradient> grad = new nsCanvasGradient(gradpat);
+    nsIDocument* doc = mCanvasElement ? mCanvasElement->OwnerDoc() : nullptr;
+    mozilla::css::Loader* cssLoader = doc ? doc->CSSLoader() : nullptr;
+    nsRefPtr<nsIDOMCanvasGradient> grad = new nsCanvasGradient(cssLoader,
+                                                               gradpat);
     if (!grad)
         return NS_ERROR_OUT_OF_MEMORY;
 
@@ -1836,7 +1851,10 @@ nsCanvasRenderingContext2D::CreateRadialGradient(float x0, float y0, float r0, f
     if (!gradpat)
         return NS_ERROR_OUT_OF_MEMORY;
 
-    nsRefPtr<nsIDOMCanvasGradient> grad = new nsCanvasGradient(gradpat);
+    nsIDocument* doc = mCanvasElement ? mCanvasElement->OwnerDoc() : nullptr;
+    mozilla::css::Loader* cssLoader = doc ? doc->CSSLoader() : nullptr;
+    nsRefPtr<nsIDOMCanvasGradient> grad = new nsCanvasGradient(cssLoader,
+                                                               gradpat);
     if (!grad)
         return NS_ERROR_OUT_OF_MEMORY;
 
diff --git a/content/canvas/src/nsCanvasRenderingContext2DAzure.cpp b/content/canvas/src/nsCanvasRenderingContext2DAzure.cpp
index d86ba32..84c1927 100644
--- a/content/canvas/src/nsCanvasRenderingContext2DAzure.cpp
+++ b/content/canvas/src/nsCanvasRenderingContext2DAzure.cpp
@@ -31,6 +31,7 @@
 #include "nsCSSParser.h"
 #include "mozilla/css/StyleRule.h"
 #include "mozilla/css/Declaration.h"
+#include "mozilla/css/Loader.h"
 #include "nsComputedDOMStyle.h"
 #include "nsStyleSet.h"
 
@@ -140,9 +141,10 @@ NS_MEMORY_REPORTER_IMPLEMENT(CanvasAzureMemory,
 class nsCanvasRadialGradientAzure : public nsCanvasGradientAzure
 {
 public:
-  nsCanvasRadialGradientAzure(const Point &aBeginOrigin, Float aBeginRadius,
+  nsCanvasRadialGradientAzure(mozilla::css::Loader* aLoader,
+                              const Point &aBeginOrigin, Float aBeginRadius,
                               const Point &aEndOrigin, Float aEndRadius)
-    : nsCanvasGradientAzure(RADIAL)
+    : nsCanvasGradientAzure(aLoader, RADIAL)
     , mCenter1(aBeginOrigin)
     , mCenter2(aEndOrigin)
     , mRadius1(aBeginRadius)
@@ -159,8 +161,9 @@ public:
 class nsCanvasLinearGradientAzure : public nsCanvasGradientAzure
 {
 public:
-  nsCanvasLinearGradientAzure(const Point &aBegin, const Point &aEnd)
-    : nsCanvasGradientAzure(LINEAR)
+  nsCanvasLinearGradientAzure(mozilla::css::Loader* aLoader,
+                              const Point &aBegin, const Point &aEnd)
+    : nsCanvasGradientAzure(aLoader, LINEAR)
     , mBegin(aBegin)
     , mEnd(aEnd)
   {
@@ -363,8 +366,17 @@ nsCanvasGradientAzure::AddColorStop(float offset, const nsAString& colorstr)
     return NS_ERROR_DOM_SYNTAX_ERR;
   }
 
+  nsIPresShell* presShell = nullptr;
+  if (mCSSLoader) {
+    nsIDocument *doc = mCSSLoader->GetDocument();
+    if (doc)
+      presShell = doc->GetShell();
+  }
+
   nscolor color;
-  if (!nsRuleNode::ComputeColor(value, nullptr, nullptr, color)) {
+  if (!nsRuleNode::ComputeColor(value,
+                          presShell ? presShell->GetPresContext() : nullptr,
+                          nullptr, color)) {
     return NS_ERROR_DOM_SYNTAX_ERR;
   }
 
@@ -1788,8 +1800,10 @@ nsCanvasRenderingContext2DAzure::CreateLinearGradient(double x0, double y0, doub
     return nullptr;
   }
 
-  nsRefPtr<nsIDOMCanvasGradient> grad =
-    new nsCanvasLinearGradientAzure(Point(x0, y0), Point(x1, y1));
+  nsIDocument* doc = mCanvasElement ? mCanvasElement->OwnerDoc() : nullptr;
+  mozilla::css::Loader* cssLoader = doc ? doc->CSSLoader() : nullptr;
+  nsRefPtr<nsIDOMCanvasGradient> grad = new nsCanvasLinearGradientAzure(
+                                     cssLoader, Point(x0, y0), Point(x1, y1));
 
   return grad.forget();
 }
@@ -1818,8 +1832,10 @@ nsCanvasRenderingContext2DAzure::CreateRadialGradient(double x0, double y0, doub
     return nullptr;
   }
 
-  nsRefPtr<nsIDOMCanvasGradient> grad =
-    new nsCanvasRadialGradientAzure(Point(x0, y0), r0, Point(x1, y1), r1);
+  nsIDocument* doc = mCanvasElement ? mCanvasElement->OwnerDoc() : nullptr;
+  mozilla::css::Loader* cssLoader = doc ? doc->CSSLoader() : nullptr;
+  nsRefPtr<nsIDOMCanvasGradient> grad = new nsCanvasRadialGradientAzure(
+                            cssLoader, Point(x0, y0), r0, Point(x1, y1), r1);
 
   return grad.forget();
 }
diff --git a/content/canvas/src/nsCanvasRenderingContext2DAzure.h b/content/canvas/src/nsCanvasRenderingContext2DAzure.h
index 05ccf61..629d78a 100644
--- a/content/canvas/src/nsCanvasRenderingContext2DAzure.h
+++ b/content/canvas/src/nsCanvasRenderingContext2DAzure.h
@@ -71,11 +71,14 @@ public:
   NS_IMETHOD AddColorStop(float offset, const nsAString& colorstr);
 
 protected:
-  nsCanvasGradientAzure(Type aType) : mType(aType)
+  nsCanvasGradientAzure(mozilla::css::Loader* aLoader, Type aType)
+      : mCSSLoader(aLoader)
+      , mType(aType)
   {}
 
   nsTArray<mozilla::gfx::GradientStop> mRawStops;
   mozilla::RefPtr<mozilla::gfx::GradientStops> mStops;
+  mozilla::css::Loader* mCSSLoader; // not ref counted, it owns us
   Type mType;
   virtual ~nsCanvasGradientAzure() {}
 };
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
index 33ce21e..078af3e 100644
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -746,7 +746,10 @@ static bool SetColor(const nsCSSValue& aValue, const nscolor aParentColor,
     int32_t intValue = aValue.GetIntValue();
     if (0 <= intValue) {
       LookAndFeel::ColorID colorID = (LookAndFeel::ColorID) intValue;
-      if (NS_SUCCEEDED(LookAndFeel::GetColor(colorID, &aResult))) {
+      bool useStandinsForNativeColors = aPresContext &&
+                                        !aPresContext->IsChrome();
+      if (NS_SUCCEEDED(LookAndFeel::GetColor(colorID,
+                                    useStandinsForNativeColors, &aResult))) {
         result = true;
       }
     }
diff --git a/widget/LookAndFeel.h b/widget/LookAndFeel.h
index e46bb13..59f00f5 100644
--- a/widget/LookAndFeel.h
+++ b/widget/LookAndFeel.h
@@ -446,6 +446,15 @@ public:
   static nsresult GetColor(ColorID aID, nscolor* aResult);
 
   /**
+   * This variant of GetColor() take an extra Boolean parameter that allows
+   * the caller to ask that hard-coded color values be substituted for
+   * native colors (used when it is desireable to hide system colors to
+   * avoid system fingerprinting).
+   */
+  static nsresult GetColor(ColorID aID, bool aUseStandinsForNativeColors,
+                           nscolor* aResult);
+
+  /**
    * GetInt() and GetFloat() return a int or float value for aID.  The result
    * might be distance, time, some flags or a int value which has particular
    * meaning.  See each document at definition of each ID for the detail.
diff --git a/widget/xpwidgets/nsXPLookAndFeel.cpp b/widget/xpwidgets/nsXPLookAndFeel.cpp
index 50c2c86..20ccfef 100644
--- a/widget/xpwidgets/nsXPLookAndFeel.cpp
+++ b/widget/xpwidgets/nsXPLookAndFeel.cpp
@@ -476,6 +476,155 @@ nsXPLookAndFeel::IsSpecialColor(ColorID aID, nscolor &aColor)
   return false;
 }
 
+bool
+nsXPLookAndFeel::ColorIsNotCSSAccessible(ColorID aID)
+{
+  bool result = false;
+
+  switch (aID) {
+    case eColorID_WindowBackground:
+    case eColorID_WindowForeground:
+    case eColorID_WidgetBackground:
+    case eColorID_WidgetForeground:
+    case eColorID_WidgetSelectBackground:
+    case eColorID_WidgetSelectForeground:
+    case eColorID_Widget3DHighlight:
+    case eColorID_Widget3DShadow:
+    case eColorID_TextBackground:
+    case eColorID_TextForeground:
+    case eColorID_TextSelectBackground:
+    case eColorID_TextSelectForeground:
+    case eColorID_TextSelectBackgroundDisabled:
+    case eColorID_TextSelectBackgroundAttention:
+    case eColorID_TextHighlightBackground:
+    case eColorID_TextHighlightForeground:
+    case eColorID_IMERawInputBackground:
+    case eColorID_IMERawInputForeground:
+    case eColorID_IMERawInputUnderline:
+    case eColorID_IMESelectedRawTextBackground:
+    case eColorID_IMESelectedRawTextForeground:
+    case eColorID_IMESelectedRawTextUnderline:
+    case eColorID_IMEConvertedTextBackground:
+    case eColorID_IMEConvertedTextForeground:
+    case eColorID_IMEConvertedTextUnderline:
+    case eColorID_IMESelectedConvertedTextBackground:
+    case eColorID_IMESelectedConvertedTextForeground:
+    case eColorID_IMESelectedConvertedTextUnderline:
+    case eColorID_SpellCheckerUnderline:
+      result = true;
+      break;
+    default:
+      break;
+  }
+
+  return result;
+}
+
+nscolor
+nsXPLookAndFeel::GetStandinForNativeColor(ColorID aID)
+{
+  nscolor result = NS_RGB(0xFF, 0xFF, 0xFF);
+
+  // The stand-in colors are taken from the Windows 7 Aero theme
+  // except Mac-specific colors which are taken from Mac OS 10.7.
+  switch (aID) {
+    // CSS 2 colors:
+    case eColorID_activeborder:      result = NS_RGB(0xB4, 0xB4, 0xB4); break;
+    case eColorID_activecaption:     result = NS_RGB(0x99, 0xB4, 0xD1); break;
+    case eColorID_appworkspace:      result = NS_RGB(0xAB, 0xAB, 0xAB); break;
+    case eColorID_background:        result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID_buttonface:        result = NS_RGB(0xF0, 0xF0, 0xF0); break;
+    case eColorID_buttonhighlight:   result = NS_RGB(0xFF, 0xFF, 0xFF); break;
+    case eColorID_buttonshadow:      result = NS_RGB(0xA0, 0xA0, 0xA0); break;
+    case eColorID_buttontext:        result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID_captiontext:       result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID_graytext:          result = NS_RGB(0x6D, 0x6D, 0x6D); break;
+    case eColorID_highlight:         result = NS_RGB(0x33, 0x99, 0xFF); break;
+    case eColorID_highlighttext:     result = NS_RGB(0xFF, 0xFF, 0xFF); break;
+    case eColorID_inactiveborder:    result = NS_RGB(0xF4, 0xF7, 0xFC); break;
+    case eColorID_inactivecaption:   result = NS_RGB(0xBF, 0xCD, 0xDB); break;
+    case eColorID_inactivecaptiontext:
+      result = NS_RGB(0x43, 0x4E, 0x54); break;
+    case eColorID_infobackground:    result = NS_RGB(0xFF, 0xFF, 0xE1); break;
+    case eColorID_infotext:          result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID_menu:              result = NS_RGB(0xF0, 0xF0, 0xF0); break;
+    case eColorID_menutext:          result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID_scrollbar:         result = NS_RGB(0xC8, 0xC8, 0xC8); break;
+    case eColorID_threeddarkshadow:  result = NS_RGB(0x69, 0x69, 0x69); break;
+    case eColorID_threedface:        result = NS_RGB(0xF0, 0xF0, 0xF0); break;
+    case eColorID_threedhighlight:   result = NS_RGB(0xFF, 0xFF, 0xFF); break;
+    case eColorID_threedlightshadow: result = NS_RGB(0xE3, 0xE3, 0xE3); break;
+    case eColorID_threedshadow:      result = NS_RGB(0xA0, 0xA0, 0xA0); break;
+    case eColorID_window:            result = NS_RGB(0xFF, 0xFF, 0xFF); break;
+    case eColorID_windowframe:       result = NS_RGB(0x64, 0x64, 0x64); break;
+    case eColorID_windowtext:        result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID__moz_buttondefault:
+      result = NS_RGB(0x69, 0x69, 0x69); break;
+    case eColorID__moz_field:        result = NS_RGB(0xFF, 0xFF, 0xFF); break;
+    case eColorID__moz_fieldtext:    result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID__moz_dialog:       result = NS_RGB(0xF0, 0xF0, 0xF0); break;
+    case eColorID__moz_dialogtext:   result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID__moz_dragtargetzone:
+      result = NS_RGB(0xFF, 0xFF, 0xFF); break;
+    case eColorID__moz_cellhighlight:
+      result = NS_RGB(0xF0, 0xF0, 0xF0); break;
+    case eColorID__moz_cellhighlighttext:
+      result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID__moz_html_cellhighlight:
+      result = NS_RGB(0x33, 0x99, 0xFF); break;
+    case eColorID__moz_html_cellhighlighttext:
+      result = NS_RGB(0xFF, 0xFF, 0xFF); break;
+    case eColorID__moz_buttonhoverface:
+      result = NS_RGB(0xF0, 0xF0, 0xF0); break;
+    case eColorID__moz_buttonhovertext:
+      result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID__moz_menuhover:
+      result = NS_RGB(0x33, 0x99, 0xFF); break;
+    case eColorID__moz_menuhovertext:
+      result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID__moz_menubartext:
+      result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID__moz_menubarhovertext:
+      result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID__moz_oddtreerow:
+      result = NS_RGB(0xFF, 0xFF, 0xFF); break;
+    case eColorID__moz_mac_chrome_active:
+      result = NS_RGB(0xB2, 0xB2, 0xB2); break;
+    case eColorID__moz_mac_chrome_inactive:
+      result = NS_RGB(0xE1, 0xE1, 0xE1); break;
+    case eColorID__moz_mac_focusring:
+      result = NS_RGB(0x60, 0x9D, 0xD7); break;
+    case eColorID__moz_mac_menuselect:
+      result = NS_RGB(0x38, 0x75, 0xD7); break;
+    case eColorID__moz_mac_menushadow:
+      result = NS_RGB(0xA3, 0xA3, 0xA3); break;
+    case eColorID__moz_mac_menutextdisable:
+      result = NS_RGB(0x88, 0x88, 0x88); break;
+    case eColorID__moz_mac_menutextselect:
+      result = NS_RGB(0xFF, 0xFF, 0xFF); break;
+    case eColorID__moz_mac_disabledtoolbartext:
+      result = NS_RGB(0x3F, 0x3F, 0x3F); break;
+    case eColorID__moz_mac_alternateprimaryhighlight:
+      result = NS_RGB(0x38, 0x75, 0xD7); break;
+    case eColorID__moz_mac_secondaryhighlight:
+      result = NS_RGB(0xD4, 0xD4, 0xD4); break;
+    case eColorID__moz_win_mediatext:
+      result = NS_RGB(0xFF, 0xFF, 0xFF); break;
+    case eColorID__moz_win_communicationstext:
+      result = NS_RGB(0xFF, 0xFF, 0xFF); break;
+    case eColorID__moz_nativehyperlinktext:
+      result = NS_RGB(0x00, 0x66, 0xCC); break;
+    case eColorID__moz_comboboxtext:
+      result = NS_RGB(0x00, 0x00, 0x00); break;
+    case eColorID__moz_combobox:
+      result = NS_RGB(0xFF, 0xFF, 0xFF); break;
+    default:
+      break;
+  }
+
+  return result;
+}
+
 //
 // All these routines will return NS_OK if they have a value,
 // in which case the nsLookAndFeel should use that value;
@@ -483,7 +632,8 @@ nsXPLookAndFeel::IsSpecialColor(ColorID aID, nscolor &aColor)
 // platform-specific nsLookAndFeel should use its own values instead.
 //
 nsresult
-nsXPLookAndFeel::GetColorImpl(ColorID aID, nscolor &aResult)
+nsXPLookAndFeel::GetColorImpl(ColorID aID, bool aUseStandinsForNativeColors,
+                              nscolor &aResult)
 {
   if (!sInitialized)
     Init();
@@ -569,7 +719,10 @@ nsXPLookAndFeel::GetColorImpl(ColorID aID, nscolor &aResult)
   }
 #endif // DEBUG_SYSTEM_COLOR_USE
 
-  if (IS_COLOR_CACHED(aID)) {
+  if (aUseStandinsForNativeColors && ColorIsNotCSSAccessible(aID))
+    aUseStandinsForNativeColors = false;
+
+  if (!aUseStandinsForNativeColors && IS_COLOR_CACHED(aID)) {
     aResult = sCachedColors[aID];
     return NS_OK;
   }
@@ -603,6 +756,12 @@ nsXPLookAndFeel::GetColorImpl(ColorID aID, nscolor &aResult)
     return NS_OK;
   }
 
+  if (sUseNativeColors && aUseStandinsForNativeColors)
+  {
+    aResult = GetStandinForNativeColor(aID);
+    return NS_OK;
+  }
+
   if (sUseNativeColors && NS_SUCCEEDED(NativeGetColor(aID, aResult))) {
     if ((gfxPlatform::GetCMSMode() == eCMSMode_All) &&
          !IsSpecialColor(aID, aResult)) {
@@ -693,7 +852,15 @@ namespace mozilla {
 nsresult
 LookAndFeel::GetColor(ColorID aID, nscolor* aResult)
 {
-  return nsLookAndFeel::GetInstance()->GetColorImpl(aID, *aResult);
+  return nsLookAndFeel::GetInstance()->GetColorImpl(aID, false, *aResult);
+}
+
+nsresult
+LookAndFeel::GetColor(ColorID aID, bool aUseStandinsForNativeColors,
+                      nscolor* aResult)
+{
+  return nsLookAndFeel::GetInstance()->GetColorImpl(aID,
+                                       aUseStandinsForNativeColors, *aResult);
 }
 
 // static
diff --git a/widget/xpwidgets/nsXPLookAndFeel.h b/widget/xpwidgets/nsXPLookAndFeel.h
index 69627d2..2729803 100644
--- a/widget/xpwidgets/nsXPLookAndFeel.h
+++ b/widget/xpwidgets/nsXPLookAndFeel.h
@@ -52,7 +52,8 @@ public:
   // otherwise we'll return NS_ERROR_NOT_AVAILABLE, in which case, the
   // platform-specific nsLookAndFeel should use its own values instead.
   //
-  nsresult GetColorImpl(ColorID aID, nscolor &aResult);
+  nsresult GetColorImpl(ColorID aID, bool aUseStandinsForNativeColors,
+                        nscolor &aResult);
   virtual nsresult GetIntImpl(IntID aID, int32_t &aResult);
   virtual nsresult GetFloatImpl(FloatID aID, float &aResult);
 
@@ -89,6 +90,8 @@ protected:
   void InitColorFromPref(int32_t aIndex);
   virtual nsresult NativeGetColor(ColorID aID, nscolor &aResult) = 0;
   bool IsSpecialColor(ColorID aID, nscolor &aColor);
+  bool ColorIsNotCSSAccessible(ColorID aID);
+  nscolor GetStandinForNativeColor(ColorID aID);
 
   static int OnPrefChanged(const char* aPref, void* aClosure);
 
-- 
1.7.5.4


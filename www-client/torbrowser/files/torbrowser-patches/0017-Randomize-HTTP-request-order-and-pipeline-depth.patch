From db11101312a3bb8912817fa910a87ce0ebd9c00d Mon Sep 17 00:00:00 2001
From: Mike Perry <mikeperry-git@torproject.org>
Date: Tue, 4 Dec 2012 17:38:51 -0800
Subject: [PATCH 17/26] Randomize HTTP request order and pipeline depth.

This is an experimental defense against
http://lorre.uni.lu/~andriy/papers/acmccs-wpes11-fingerprinting.pdf

See:
https://blog.torproject.org/blog/experimental-defense-website-traffic-fingerprinting

This defense has been improved since that blog post to additionally randomize
the order and concurrency of non-pipelined HTTP requests.

This patch is also different from the 10.x ESR patch, as the pipelining
code has changed. We may want to set network.http.pipelining.aggressive to get
similar behavior...

The good news is we now randomize SPDY request order as well as pipeline
request order (though SPDY is still disabled by default in TBB).
---
 netwerk/protocol/http/nsHttpConnectionMgr.cpp |   67 +++++++++++++++++++++++--
 netwerk/protocol/http/nsHttpConnectionMgr.h   |    3 +
 2 files changed, 65 insertions(+), 5 deletions(-)

diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.cpp b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
index 133c301..59d03c0 100644
--- a/netwerk/protocol/http/nsHttpConnectionMgr.cpp
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
@@ -20,6 +20,8 @@
 #include "prnetdb.h"
 #include "mozilla/Telemetry.h"
 
+#include <stdlib.h>
+
 using namespace mozilla;
 using namespace mozilla::net;
 
@@ -39,15 +41,46 @@ InsertTransactionSorted(nsTArray<nsHttpTransaction*> &pendingQ, nsHttpTransactio
     // insert into queue with smallest valued number first.  search in reverse
     // order under the assumption that many of the existing transactions will
     // have the same priority (usually 0).
+    uint32_t len = pendingQ.Length();
+    uint32_t begin = 0, end = len+1;
+    int found_begin = 0;
 
-    for (int32_t i=pendingQ.Length()-1; i>=0; --i) {
+    if (pendingQ.IsEmpty()) {
+        pendingQ.InsertElementAt(0, trans);
+        return;
+    }
+
+// #define PRESERVE_PRIORITY_ORDER 
+#ifdef PRESERVE_PRIORITY_ORDER
+    // XXX: Untested
+    for (uint32_t i=0; i < len; ++i) {
         nsHttpTransaction *t = pendingQ[i];
-        if (trans->Priority() >= t->Priority()) {
-            pendingQ.InsertElementAt(i+1, trans);
-            return;
+
+        /* As soon as we see a priority >= us, our insertion
+         * range starts there */
+        if (!found_begin && t->Priority() >= trans->Priority()) {
+            begin = i;
+            found_begin = 1;
+        }
+        /* As soon as we see a priority > us, our insertion
+         * range ends there */
+        if (t->Priority() > trans->Priority()) {
+            end = i;
+            break;
         }
     }
-    pendingQ.InsertElementAt(0, trans);
+
+    // XXX Verify that begin..end are all == trans->Priority()
+#endif
+
+    // Choose random destination begin..end
+    uint32_t count = end - begin;
+    if (count == 0) count = 1;
+
+    // FIXME: rand() is not crypto-secure.. but meh, this code will probably
+    // change like 2 dozen more times before merge, and rand() is probably 
+    // good enough for our purposes anyways.
+    pendingQ.InsertElementAt(begin + (rand()%count), trans);
 }
 
 //-----------------------------------------------------------------------------
@@ -68,6 +101,12 @@ nsHttpConnectionMgr::nsHttpConnectionMgr()
     mCT.Init();
     mAlternateProtocolHash.Init(16);
     mSpdyPreferredHash.Init();
+
+    nsresult rv;
+    mRandomGenerator = do_GetService("@mozilla.org/security/random-generator;1", &rv);
+    if (NS_FAILED(rv)) {
+        mRandomGenerator = nullptr;
+    }
 }
 
 nsHttpConnectionMgr::~nsHttpConnectionMgr()
@@ -1120,6 +1159,19 @@ nsHttpConnectionMgr::AtActiveConnectionLimit(nsConnectionEntry *ent, uint8_t cap
 
     LOG(("   connection count = %d, limit %d\n", totalCount, maxPersistConns));
 
+    // Fuzz maxConns for website fingerprinting attack
+    // We create a range of maxConns/5 up to 6*maxConns/5 
+    // because this function is called repeatedly, and we'll
+    // end up converging on the high side of concurrent connections
+    // after a short while. 
+    PRUint8 *bytes = nullptr;
+    nsresult rv = mRandomGenerator->GenerateRandomBytes(1, &bytes);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    bytes[0] = bytes[0] % (maxPersistConns + 1);
+    maxPersistConns = (maxPersistConns/5) + bytes[0];
+    NS_Free(bytes);
+
     // use >= just to be safe
     bool result = (totalCount >= maxPersistConns);
     LOG(("  result: %s", result ? "true" : "false"));
@@ -1297,6 +1349,11 @@ nsHttpConnectionMgr::AddToShortestPipeline(nsConnectionEntry *ent,
 
     maxdepth = PR_MIN(maxdepth, depthLimit);
 
+    if (maxdepth/2 > 1) { 
+      // This is a crazy hack to randomize pipeline depth a bit more..
+      maxdepth = 1 + maxdepth/2 + (rand() % (maxdepth/2));
+    }
+
     if (maxdepth < 2)
         return false;
 
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.h b/netwerk/protocol/http/nsHttpConnectionMgr.h
index 580710a..b22c669 100644
--- a/netwerk/protocol/http/nsHttpConnectionMgr.h
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.h
@@ -23,6 +23,7 @@
 #include "nsIObserver.h"
 #include "nsITimer.h"
 #include "nsIX509Cert3.h"
+#include "nsIRandomGenerator.h"
 
 class nsHttpPipeline;
 
@@ -585,6 +586,8 @@ private:
     uint64_t mTimeOfNextWakeUp;
     // Timer for next pruning of dead connections.
     nsCOMPtr<nsITimer> mTimer;
+    // Random number generator for reordering HTTP pipeline
+    nsCOMPtr<nsIRandomGenerator>             mRandomGenerator;
 
     // A 1s tick to call nsHttpConnection::ReadTimeoutTick on
     // active http/1 connections and check for orphaned half opens.
-- 
1.7.5.4

